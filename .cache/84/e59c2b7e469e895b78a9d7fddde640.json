{"id":"services/Room.js","dependencies":[{"name":"/Users/birusnt/Development/drawguys-api/package.json","includedInParent":true,"mtime":1600701192072},{"name":"../socket.js","loc":{"line":1,"column":19},"parent":"/Users/birusnt/Development/drawguys-api/services/Room.js","resolved":"/Users/birusnt/Development/drawguys-api/socket.js"}],"generated":{"js":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst io = require('../socket.js').getio();\n\nconst _ = require('lodash');\n\nconst LOG = true;\nlet rooms = {};\nlet defaultRoom = {\n  roomid: '',\n  roomname: '',\n  active: false,\n  users: {},\n  sockets: [],\n  messages: []\n};\nlet defaultRoomUser = {\n  guesses: [],\n  ready: false,\n  match: false,\n  typing: false,\n  color: '',\n  score: 0\n}; // socket events\n\nio.on('connection', socket => {\n  socket.on('create_room', room => createRoom(room, socket));\n  socket.on('join_room', roomid => joinRoom(roomid, socket));\n  socket.on('leave_room', roomid => leaveRoom(roomid, socket));\n  socket.on('toggle_ready', userid => toggleReady(userid, socket));\n  socket.on('disconnecting', () => {\n    if (socket.roomid) {\n      leaveRoom(socket.roomid, socket);\n    }\n  }); // init rooms\n\n  setTimeout(() => brodcastRooms, 50);\n}); // actions\n\nfunction createRoom(room, socket) {\n  log('create-room', room.roomid); // validation\n\n  if (!socket || !room.roomid) {\n    log('create-room:error', room.roomid);\n    return;\n  } // add room to rooms object\n\n\n  rooms[room.roomid] = _objectSpread(_objectSpread({}, _.cloneDeep(defaultRoom)), room); // join room after it's created\n\n  joinRoom(room.roomid, socket);\n}\n\nfunction removeRoom(roomid) {\n  log('remove-room', roomid); // validation\n\n  if (!socket || !roomid || !rooms[roomid]) {\n    log('remove-room:error', room.roomid);\n    return;\n  } // remove room from rooms object\n\n\n  delete rooms[roomid];\n  brodcastRooms();\n}\n\nfunction joinRoom(roomid, socket) {\n  log('join-room', roomid);\n  let room = rooms[roomid]; // validation\n\n  if (!socket || !room) {\n    log('join-room:error', socket.userid);\n    socket.emit('join_room_error');\n    return;\n  } // join room\n\n\n  socket.join(roomid, () => {\n    // set socket roomid\n    socket.roomid = roomid; // add socket to room\n\n    room.sockets.push(socket); // add user to room\n\n    room.users[socket.userid] = _objectSpread(_objectSpread({}, _.cloneDeep(defaultRoomUser)), {}, {\n      username: socket.username,\n      userid: socket.userid,\n      color: 'blue' // TODO\n\n    });\n    brodcastRooms();\n    updateRoom(room);\n  });\n}\n\nfunction leaveRoom(roomid, socket) {\n  log('leave-room', roomid);\n  let room = rooms[roomid]; // validation\n\n  if (!socket || !room || !room.users[socket.userid]) {\n    log('leave-room:error', roomid);\n    return;\n  }\n\n  socket.leave(roomid, () => {\n    // reset roomid on socket\n    socket.roomid = ''; // remove user object from room\n\n    delete room.users[socket.userid]; // remove socket\n\n    const index = room.sockets.findIndex(s => s.userid === socket.userid);\n\n    if (index > -1) {\n      room.sockets.splice(index, 1);\n    } // if the room is empty, remove the room\n\n\n    if (room.sockets.length === 0) {\n      removeRoom(roomid);\n    } else {\n      brodcastRooms();\n      updateRoom(room);\n    }\n  });\n}\n\nfunction toggleReady(userid, socket) {\n  log('toggle-ready', userid);\n  let room = rooms[socket.roomid]; // validation\n\n  if (!socket || !room || !room.users[userid]) {\n    log('toggle-ready:error', roomid);\n    return;\n  } // toggle ready\n\n\n  room.users[userid].ready = !room.users[userid].ready; // update\n\n  updateRoom(room);\n} // broadcasts\n\n\nfunction brodcastRooms() {\n  // log('broadcast-rooms')\n  io.emit('update_rooms', formatRooms(rooms));\n}\n\nfunction updateRoom(room) {\n  // log('broadcast-room-update', room.roomid)\n  for (const client of room.sockets) {\n    client.emit('update_room', formatRoom(room));\n  }\n} // helpers\n\n\nfunction log(message, roomid) {\n  if (LOG) {\n    console.log(`room:${message}`, roomid);\n  }\n}\n\nfunction formatRooms() {\n  let returnRooms = {};\n  let roomids = Object.keys(_.cloneDeep(rooms));\n  roomids.forEach(roomid => {\n    returnRooms[roomid] = formatRoom(_.cloneDeep(rooms[roomid]));\n  });\n  return returnRooms;\n}\n\nfunction formatRoom(room) {\n  return _.cloneDeep(_objectSpread(_objectSpread({}, room), {}, {\n    game: null,\n    sockets: []\n  }));\n}"},"sourceMaps":null,"error":null,"hash":"cdc1c8bef329d5c31a767517799d8800","cacheData":{"env":{}}}