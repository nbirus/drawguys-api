{"id":"services/Room.js","dependencies":[{"name":"/Users/birusnt/Development/drawguys-api/package.json","includedInParent":true,"mtime":1601323522620},{"name":"../socket.js","loc":{"line":1,"column":19},"parent":"/Users/birusnt/Development/drawguys-api/services/Room.js","resolved":"/Users/birusnt/Development/drawguys-api/socket.js"},{"name":"../assets/colors","loc":{"line":3,"column":25},"parent":"/Users/birusnt/Development/drawguys-api/services/Room.js","resolved":"/Users/birusnt/Development/drawguys-api/assets/colors.js"}],"generated":{"js":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst io = require('../socket.js').getio();\n\nconst _ = require('lodash');\n\nconst getColor = require('../assets/colors').default;\n\nconst LOG = true;\nlet rooms = {// test: {\n  //   roomid: 'test',\n  //   roomname: 'test',\n  //   active: false,\n  //   users: {\n  //     test: {\n  //       guesses: [],\n  //       ready: false,\n  //       match: false,\n  //       typing: false,\n  //       color: 'blue',\n  //       score: 0,\n  //       username: 'Usernmae',\n  //     },\n  //     test2: {\n  //       guesses: [],\n  //       ready: false,\n  //       match: false,\n  //       typing: false,\n  //       color: 'maroon',\n  //       score: 0,\n  //       username: 'Other',\n  //     },\n  //   },\n  //   sockets: [],\n  //   messages: [],\n  // },\n  // test2: {\n  //   roomid: 'test',\n  //   roomname: 'Room Name',\n  //   active: false,\n  //   users: {\n  //     test: {\n  //       guesses: [],\n  //       ready: false,\n  //       match: false,\n  //       typing: false,\n  //       color: 'orange',\n  //       score: 0,\n  //       username: 'Test',\n  //     },\n  //   },\n  //   sockets: [],\n  //   messages: [],\n  // },\n  // test3: {\n  //   roomid: 'test',\n  //   roomname: 'Room Three',\n  //   active: false,\n  //   users: {\n  //     test: {\n  //       guesses: [],\n  //       ready: false,\n  //       match: false,\n  //       typing: false,\n  //       color: 'purple',\n  //       score: 0,\n  //       username: 'Lorium',\n  //     },\n  //     test2: {\n  //       guesses: [],\n  //       ready: false,\n  //       match: false,\n  //       typing: false,\n  //       color: 'green',\n  //       score: 0,\n  //       username: 'Other',\n  //     },\n  //     test2: {\n  //       guesses: [],\n  //       ready: false,\n  //       match: false,\n  //       typing: false,\n  //       color: 'red',\n  //       score: 0,\n  //       username: 'Other',\n  //     },\n  //   },\n  //   sockets: [],\n  //   messages: [],\n  // },\n  // test4: {\n  //   roomid: 'test',\n  //   roomname: 'test',\n  //   active: false,\n  //   users: {\n  //     test: {\n  //       guesses: [],\n  //       ready: false,\n  //       match: false,\n  //       typing: false,\n  //       color: 'blue',\n  //       score: 0,\n  //       username: 'Usernmae',\n  //     },\n  //     test2: {\n  //       guesses: [],\n  //       ready: false,\n  //       match: false,\n  //       typing: false,\n  //       color: 'maroon',\n  //       score: 0,\n  //       username: 'Other',\n  //     },\n  //   },\n  //   sockets: [],\n  //   messages: [],\n  // },\n};\nlet defaultRoom = {\n  roomid: '',\n  roomname: '',\n  active: false,\n  users: {},\n  sockets: [],\n  messages: []\n};\nlet defaultRoomUser = {\n  guesses: [],\n  ready: false,\n  match: false,\n  typing: false,\n  color: '',\n  score: 0\n}; // socket events\n\nio.on('connection', socket => {\n  socket.on('get_rooms', () => getRooms(socket));\n  socket.on('create_room', room => createRoom(room, socket));\n  socket.on('join_room', roomid => joinRoom(roomid, socket));\n  socket.on('leave_room', roomid => leaveRoom(roomid, socket));\n  socket.on('toggle_ready', userid => toggleReady(userid, socket));\n  socket.on('message', message => addMessage(message, socket));\n  socket.on('color', color => setColor(color, socket));\n  socket.on('typing', typing => setTyping(typing, socket));\n  socket.on('disconnecting', () => {\n    if (socket.roomid) {\n      leaveRoom(socket.roomid, socket);\n    }\n  });\n}); // actions\n\nfunction getRooms(socket) {\n  socket.emit('update_rooms', formatRooms(rooms));\n}\n\nfunction createRoom(room, socket) {\n  log('create-room', room.roomid); // validation\n\n  if (!socket || !room.roomid) {\n    log('create-room:error', room.roomid);\n    return;\n  } // add room to rooms object\n\n\n  rooms[room.roomid] = _objectSpread(_objectSpread({}, _.cloneDeep(defaultRoom)), room); // join room after it's created\n\n  joinRoom(room.roomid, socket);\n}\n\nfunction removeRoom(roomid) {\n  log('remove-room', roomid); // validation\n\n  if (!socket || !roomid || !rooms[roomid]) {\n    log('remove-room:error', room.roomid);\n    return;\n  } // remove room from rooms object\n\n\n  delete rooms[roomid];\n  brodcastRooms();\n}\n\nfunction joinRoom(roomid, socket) {\n  log('join-room', roomid);\n  let room = rooms[roomid]; // validation\n\n  if (!socket || !room || Object.keys(room.users).length === 8) {\n    log('join-room:error', socket.userid);\n    socket.emit('join_room_error');\n    return;\n  } // join room\n\n\n  socket.join(roomid, () => {\n    // set socket roomid\n    socket.roomid = roomid;\n    socket.color = getColor(room.users); // add socket to room\n\n    room.sockets.push(socket); // add user to room\n\n    room.users[socket.userid] = _objectSpread(_objectSpread({}, _.cloneDeep(defaultRoomUser)), {}, {\n      username: socket.username,\n      userid: socket.userid,\n      color: socket.color\n    });\n    addMessage('', socket, 'join-room');\n    brodcastRooms();\n    updateRoom(room);\n  });\n}\n\nfunction leaveRoom(roomid, socket) {\n  log('leave-room', roomid);\n  let room = rooms[roomid]; // validation\n\n  if (!socket || !room || !room.users[socket.userid]) {\n    log('leave-room:error', roomid);\n    return;\n  }\n\n  addMessage('', socket, 'leave-room');\n  socket.leave(roomid, () => {\n    // reset roomid on socket\n    socket.roomid = ''; // remove user object from room\n\n    delete room.users[socket.userid]; // remove socket\n\n    const index = room.sockets.findIndex(s => s.userid === socket.userid);\n\n    if (index > -1) {\n      room.sockets.splice(index, 1);\n    } // if the room is empty, remove the room\n\n\n    if (room.sockets.length === 0) {\n      removeRoom(roomid);\n    } else {\n      brodcastRooms();\n      updateRoom(room);\n    }\n  });\n}\n\nfunction toggleReady(userid, socket) {\n  log('toggle-ready', userid);\n  let room = rooms[socket.roomid]; // validation\n\n  if (!socket || !room || !room.users[userid]) {\n    log('toggle-ready:error', socket.roomid);\n    return;\n  } // toggle ready\n\n\n  room.users[userid].ready = !room.users[userid].ready;\n  let userArray = Object.values(room.users);\n\n  if (userArray.length > 1 && userArray.every(user => user.ready)) {\n    startGameCountdown(socket);\n  } else {\n    stopGameCountdown(socket);\n  }\n\n  brodcastRooms();\n  updateRoom(room);\n}\n\nfunction addMessage(message, socket, event) {\n  log('message', message);\n  let room = rooms[socket.roomid]; // validation\n\n  if (!socket || !room) {\n    log('message:error', message);\n    return;\n  } // add message\n\n\n  room.messages.push({\n    username: socket.username,\n    userid: socket.userid,\n    message,\n    event\n  }); // update\n\n  updateRoom(room);\n}\n\nfunction setColor(color, socket) {\n  let room = rooms[socket.roomid]; // validation\n\n  if (!socket || !room || !room.users[socket.userid]) {\n    log('set-color:error', socket.userid);\n    return;\n  }\n\n  room.users[socket.userid].color = color;\n  brodcastRooms();\n  updateRoom(room);\n}\n\nfunction setTyping(typing, socket) {\n  let room = rooms[socket.roomid]; // validation\n\n  if (!socket || !room || !room.users[socket.userid]) {\n    log('set-typing:error', socket.userid);\n    return;\n  }\n\n  room.users[socket.userid].typing = typing;\n  updateRoom(room);\n}\n\nfunction startGame(socket) {\n  log('start');\n  let room = rooms[socket.roomid]; // validation\n\n  if (!socket || !room || !room.users[userid]) {\n    log('start:error', socket.roomid);\n    return;\n  } // set game to active\n\n\n  room.active = true;\n  updateRoom(room);\n  brodcastRooms();\n}\n\nlet countdownInterval = null;\n\nfunction startGameCountdown(socket) {\n  let count = 3;\n  countdownInterval = setInterval(countDown, 1000);\n\n  function countDown() {\n    addMessage(count, socket, 'countdown');\n\n    if (count === 0) {\n      clearInterval(countdownInterval);\n      countdownInterval = null;\n      startGame(socket);\n    }\n\n    count--;\n  }\n}\n\nfunction stopGameCountdown(socket) {\n  if (countdownInterval) {\n    addMessage('', socket, 'countdown-cancel');\n    clearInterval(countdownInterval);\n    countdownInterval = null;\n  }\n} // broadcasts\n\n\nfunction brodcastRooms() {\n  io.emit('update_rooms', formatRooms(rooms));\n}\n\nfunction updateRoom(room) {\n  for (const client of room.sockets) {\n    client.emit('update_room', formatRoom(room));\n  }\n} // helpers\n\n\nfunction log(message, roomid) {\n  if (LOG) {\n    console.log(`room:${message}`, roomid);\n  }\n}\n\nfunction formatRooms() {\n  let returnRooms = {};\n  let roomids = Object.keys(_.cloneDeep(rooms));\n  roomids.forEach(roomid => {\n    returnRooms[roomid] = formatRoom(_.cloneDeep(rooms[roomid]));\n  });\n  return returnRooms;\n}\n\nfunction formatRoom(room) {\n  return _.cloneDeep(_objectSpread(_objectSpread({}, room), {}, {\n    game: null,\n    sockets: []\n  }));\n}"},"sourceMaps":null,"error":null,"hash":"411579f3b7261b8052f70d6e6c80a942","cacheData":{"env":{}}}