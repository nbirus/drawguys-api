{"id":"services/Room.js","dependencies":[{"name":"/Users/birusnt/Development/drawguys-api/package.json","includedInParent":true,"mtime":1601323522620},{"name":"../socket.js","loc":{"line":1,"column":19},"parent":"/Users/birusnt/Development/drawguys-api/services/Room.js","resolved":"/Users/birusnt/Development/drawguys-api/socket.js"},{"name":"../assets/colors","loc":{"line":3,"column":25},"parent":"/Users/birusnt/Development/drawguys-api/services/Room.js","resolved":"/Users/birusnt/Development/drawguys-api/assets/colors.js"},{"name":"../game.js","loc":{"line":4,"column":21},"parent":"/Users/birusnt/Development/drawguys-api/services/Room.js","resolved":"/Users/birusnt/Development/drawguys-api/game.js"},{"name":"../countdown.js","loc":{"line":5,"column":26},"parent":"/Users/birusnt/Development/drawguys-api/services/Room.js","resolved":"/Users/birusnt/Development/drawguys-api/countdown.js"}],"generated":{"js":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst io = require('../socket.js').getio();\n\nconst _ = require('lodash');\n\nconst getColor = require('../assets/colors');\n\nconst Game = require('../game.js');\n\nconst Countdown = require('../countdown.js');\n\nconst LOG = false;\nlet rooms = {};\nlet defaultRoom = {\n  game: null,\n  roomid: '',\n  roomname: '',\n  sockets: [],\n  timer: 3,\n  timerActive: false,\n  roomTimer: null,\n  messages: [],\n  gameState: {\n    active: false,\n    event: 'pre_round',\n    timer: 0,\n    gameTimer: null,\n    turnUser: {},\n    roundWord: '',\n    round: 0,\n    numberOfRounds: 2\n  },\n  usersState: {}\n};\nlet defaultRoomUser = {\n  guesses: [],\n  ready: false,\n  match: false,\n  typing: false,\n  drawing: false,\n  color: '',\n  score: 0\n}; // socket events\n\nio.on('connection', socket => {\n  socket.on('get_rooms', () => socket.emit('update_rooms', formatRooms(rooms)));\n  socket.on('create_room', room => createRoom(room, socket));\n  socket.on('join_room', roomid => joinRoom(roomid, socket));\n  socket.on('leave_room', () => leaveRoom(socket));\n  socket.on('toggle_ready', () => toggleReady(socket));\n  socket.on('message', message => roomMessage(message, socket));\n  socket.on('color', color => setColor(color, socket));\n  socket.on('typing', typing => setTyping(typing, socket));\n  socket.on('word', word => setWord(word, socket));\n  socket.on('disconnecting', () => leaveRoom(socket));\n}); // events\n\nfunction createRoom(room, socket) {\n  log('create-room'); // if room exists, error out\n\n  if (!socket || roomExists(room.roomid)) {\n    log('create-room:error');\n    return;\n  } // create room\n\n\n  rooms[room.roomid] = getDefaultRoom(room); // join room after it's created\n\n  joinRoom(room.roomid, socket);\n}\n\nfunction removeRoom(roomid) {\n  log('remove-room'); // validation\n\n  if (!socket || !roomExists(roomid)) {\n    log('remove-room:error');\n    return;\n  } // remove room from rooms object\n\n\n  delete rooms[roomid]; // update ui\n\n  updateRooms();\n}\n\nfunction joinRoom(roomid, socket) {\n  log('join-room'); // if room doesn't exists don't join\n\n  if (!socket || !roomExists(roomid)) {\n    onSocketError(socket, 'join-room');\n    return;\n  } // if room exists and user is already in the game, do nothing\n\n\n  if (roomExists(roomid, socket.userid)) {\n    log('join-room:already-in-room');\n    updateRoomState(rooms[roomid]);\n    return;\n  } // join room\n\n\n  socket.join(roomid, () => {\n    let room = rooms[roomid]; // set socket roomid\n\n    socket.roomid = roomid;\n    socket.color = getColor(room.usersState); // add socket to room\n\n    room.sockets.push(socket); // add user to room\n\n    room.usersState[socket.userid] = getDefaultUser(socket); // add event to message\n\n    roomMessage('', socket, 'join-room'); // update state\n\n    updateRoomState(room, true);\n  });\n}\n\nfunction leaveRoom(socket) {\n  log('leave-room'); // if room or user doesn't exists don't join\n\n  if (!socket || !roomExists(socket.roomid, socket.userid)) {\n    onSocketError(socket, 'leave-room');\n    return;\n  } // add event to message\n\n\n  roomMessage('', socket, 'leave-room'); // leave room\n\n  socket.leave(socket.roomid, () => {\n    let tempRoomid = socket.roomid;\n    let room = rooms[socket.roomid]; // remove user object from room\n\n    delete room.usersState[socket.userid]; // reset socket\n\n    socket.roomid = '';\n    socket.color = ''; // remove socket\n\n    const index = room.sockets.findIndex(s => s.userid === socket.userid);\n\n    if (index > -1) {\n      room.sockets.splice(index, 1);\n    } // if the room is empty, remove the room\n\n\n    if (room.sockets.length === 0) {\n      removeRoom(tempRoomid);\n    } else {\n      updateRoomState(room, true);\n    }\n  });\n}\n\nfunction toggleReady(socket) {\n  log('toggle-ready');\n\n  if (!socket || !roomExists(socket.roomid, socket.userid)) {\n    onSocketError(socket, 'toggle-ready');\n    return;\n  } // toggle ready\n\n\n  setRoomUserState(socket, 'ready', !getRoomUserState(socket, 'ready'), true); // if all users are ready start or stop the room timer\n\n  if (allUsersReady(socket)) {\n    startRoomTimer(socket);\n  } else {\n    stopRoomTimer(socket);\n  }\n}\n\nfunction setTyping(typing, socket) {\n  log('set-typing');\n\n  if (!socket || !roomExists(socket.roomid, socket.userid)) {\n    onSocketError(socket, 'set-typing');\n    return;\n  } // toggle ready\n\n\n  setRoomUserState(socket, 'typing', typing, true);\n}\n\nfunction setWord(word, socket) {\n  log('set-word');\n\n  if (!socket || !roomExists(socket.roomid, socket.userid)) {\n    onSocketError(socket, 'set-word');\n    return;\n  }\n\n  if (isGameActive(rooms[socket.roomid])) {\n    rooms[socket.roomid].game.setWord(word);\n  }\n}\n\nfunction setColor(color, socket) {\n  log('set-color');\n\n  if (!socket || !roomExists(socket.roomid, socket.userid)) {\n    onSocketError(socket, 'set-color');\n    return;\n  } // toggle ready\n\n\n  setRoomUserState(socket, 'color', color, true);\n} // messages\n\n\nfunction roomMessage(message, socket, event) {\n  log('message');\n\n  if (!socket || !roomExists(socket.roomid, socket.userid)) {\n    onSocketError(socket, 'message');\n    return;\n  }\n\n  let room = rooms[socket.roomid];\n  room.messages.push({\n    username: socket.username,\n    userid: socket.userid,\n    message,\n    event\n  });\n  updateRoomState(room);\n} // room timer\n\n\nfunction startRoomTimer(socket) {\n  setRoomState(socket.roomid, 'timer', 3);\n  setRoomState(socket.roomid, 'timerActive', true, true);\n  rooms[socket.roomid].roomTimer = new Countdown({\n    seconds: 3,\n    update: function (interval) {\n      roomMessage(interval, socket, 'countdown');\n      setRoomState(socket.roomid, 'timer', interval, true);\n    },\n    end: function () {\n      setRoomState(socket.roomid, 'gameState.active', true, true);\n      startGame(rooms[socket.roomid]);\n    }\n  });\n  rooms[socket.roomid].roomTimer.start();\n}\n\nfunction stopRoomTimer(socket) {\n  let roundTimer = rooms[socket.roomid].roomTimer;\n  setRoomState(socket.roomid, 'timerActive', false, true);\n\n  if (roundTimer) {\n    roundTimer.stop();\n  }\n} // brodcast\n\n\nfunction updateRoomState(room, updateAllRooms = false) {\n  if (!room) {\n    return;\n  }\n\n  for (const client of room.sockets) {\n    client.emit('update_room', formatRoom(room));\n  }\n\n  if (updateAllRooms) {\n    updateRooms();\n  }\n}\n\nfunction updateRooms() {\n  io.emit('update_rooms', formatRooms(rooms));\n}\n\nfunction onSocketError(socket, message) {\n  log(`${message}:error`);\n\n  if (socket && socket.emit) {\n    socket.emit('join_room_error');\n\n    if (socket.roomid) {\n      removeRoom(socket.roomid);\n    }\n  }\n} // game\n\n\nfunction startGame(room) {\n  room.timerActive = false;\n  room.game = new Game(room, updateRooms);\n  room.game.start();\n}\n\nfunction stopGame(room) {\n  if (room.game !== null) {\n    room.game.stop();\n  }\n} // setters\n\n\nfunction setRoomState(roomid, path, value, shouldUpdate = false) {\n  _.set(rooms, `${roomid}.${path}`, value);\n\n  if (shouldUpdate) {\n    updateRoomState(rooms[roomid]);\n  }\n}\n\nfunction setRoomUserState(socket, path, value, shouldUpdate = false) {\n  _.set(rooms, `${socket.roomid}.usersState.${socket.userid}.${path}`, value);\n\n  if (shouldUpdate) {\n    updateRoomState(rooms[socket.roomid]);\n  }\n} // getters\n\n\nfunction getRoomUserState(socket, path) {\n  return _.get(rooms, `${socket.roomid}.usersState.${socket.userid}.${path}`);\n} // helpers\n\n\nfunction allUsersReady(socket) {\n  let userArray = Object.values(_.get(rooms, `${socket.roomid}.usersState`));\n  return userArray.length > 1 && userArray.every(user => user.ready);\n}\n\nfunction roomExists(roomid, userid) {\n  // if the room isn't defined\n  if (rooms[roomid] === undefined) {\n    // log('room-not-found')\n    return false;\n  } // if the user isn't defined\n  else if (userid !== undefined && _.get(rooms, `${roomid}.usersState.${userid}`) === undefined) {\n      // log('user-not-found')\n      return false;\n    } else return true;\n}\n\nfunction getDefaultRoom(room) {\n  return _objectSpread(_objectSpread({}, _.cloneDeep(defaultRoom)), room);\n}\n\nfunction getDefaultUser(socket) {\n  return _objectSpread(_objectSpread({}, _.cloneDeep(defaultRoomUser)), {}, {\n    username: socket.username,\n    userid: socket.userid,\n    color: socket.color\n  });\n}\n\nfunction log(message) {\n  if (LOG) {\n    console.log(`room:${message}`);\n  }\n}\n\nfunction formatRooms() {\n  let returnRooms = {};\n  let roomids = Object.keys(_.cloneDeep(rooms));\n  roomids.forEach(roomid => {\n    returnRooms[roomid] = formatRoom(_.cloneDeep(rooms[roomid]));\n  });\n  return returnRooms;\n}\n\nfunction formatRoom(room) {\n  return _.cloneDeep(_objectSpread(_objectSpread({}, room), {}, {\n    game: null,\n    sockets: []\n  }));\n}\n\nfunction isGameActive(room) {\n  return room.game !== null;\n}\n\nmodule.exports = {\n  joinRoom,\n  updateRooms\n};"},"sourceMaps":null,"error":null,"hash":"43baa1d26ee7966e960f33e5c24ebceb","cacheData":{"env":{}}}